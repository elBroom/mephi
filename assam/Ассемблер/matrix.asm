;суммирование матрицы по строкам и по столбцам
.model small
.stack 100h
.data

;определим размер матрицы
	m	equ	3
	n 	equ	4

;зададим саму матрицу - ВНИМАНИЕ, в конце каждой строки запятой НЕТУ!
	a 	db 	1,2,3,4
	  	db 	5,6,7,8
		db 	9,10,11,12

;для вящей точности зададим суммы как слова
	sumstr	dw	?
	sumcol	dw	?

.code
.486

	mov	ax, @data
	mov	ds, ax

;СУММИРОВАНИЕ ПО СТРОКАМ
;в BX будем хранить номер строки, в SI - номер столбца. Вся нумерация начинается с нуля
	xor     bx, bx
	xor	ax, ax	;тут будем копить результат
	mov	cx, m	;внешний цикл будет перебирать строки

;начало расчета
c_ext:	push	cx	;запоминаем текущее значение параметра внешнего цикла в стеке
	mov	cx, n	;внутренний цикл для перебора элементов в каждой строке, т.е. по столбцу
	xor	si, si	;обнуляем номер столбца
c_int:	add	al, byte ptr a[bx][si] ; это базовая индексная адресация со смещением 
	adc	ah, 0
	inc	si      ;переход к следующему столбцу
	loop	c_int	
	pop	cx
	add	bx,n    ;переходим к следующей строке
	loop	c_ext	

	mov	sumstr, ax

;СУММИРОВАНИЕ ПО СТОЛБЦАМ
;в BX будем хранить номер строки, в SI - номер столбца. Вся нумерация начинается с нуля
	xor     si, si
	xor	ax, ax	;тут будем копить результат
	mov	cx, n	;внешний цикл будет перебирать столбцы

;начало расчета
c_ext1:	push	cx	;запоминаем текущее значение параметра внешнего цикла в стеке
	mov	cx, m	;внутренний цикл для перебора элементов в каждом столбце, т.е. по столбцу
	xor	bx, bx	;обнуляем номер строки
c_int1:	add	al, byte ptr a[bx][si] ; это базовая индексная адресация со смещением 
	adc	ah, 0
	add	bx, n   ;переходим к следующей строке
	loop	c_int1	
	pop	cx
	inc	si    	;переходим к следующему столбцу
	loop	c_ext1	

	mov	sumcol, ax

	mov 	ah, 4ch
	int	21h
end